// Copyright (c) 2017 Walter Kuppens
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <stdio.h>

#include "interpreter.h"
#include "program.h"

void bf_transpile_program(struct bf_program *program, FILE *fp)
{
    struct bf_instruction *instr;

    fprintf(fp, "// Generated by mlbf - https://github.com/Reshurum/mlbf\n\n");
    fprintf(fp, "#include <stdint.h>\n");
    fprintf(fp, "#include <stdio.h>\n");
    fprintf(fp, "#include <stdlib.h>\n\n");

    fprintf(fp, "int main(int argc, char *argv[])\n{\n");

    fprintf(fp, "uint8_t *memory = calloc(1, sizeof(int8_t) * %d);\n", BF_MEMORY_SIZE);
    fprintf(fp, "size_t pointer = 0;\n");
    fprintf(fp, "uint16_t pointer_holder = 0;\n");
    fprintf(fp, "int input = 0;\n");

    fprintf(fp, "if (!memory) {\n");
    fprintf(fp, "goto error1;\n");
    fprintf(fp, "}\n");

    for (int i = 0; i < program->size; i++) {
        instr = &program->ir[i];

        switch (instr->opcode) {
        case BF_INS_NOP:
            break;
        case BF_INS_IN:
            fprintf(fp, "if ((input = getchar()) != EOF) {\n");
            fprintf(fp, "memory[pointer] = input;\n");
            fprintf(fp, "}\n");
            break;
        case BF_INS_OUT:
            fprintf(fp, "putchar(memory[pointer]);\n");
            break;
        case BF_INS_INC_V:
            fprintf(fp, "memory[pointer]++;\n");
            break;
        case BF_INS_DEC_V:
            fprintf(fp, "memory[pointer]--;\n");
            break;
        case BF_INS_ADD_V:
            fprintf(fp, "memory[pointer] += %d;\n", instr->argument);
            break;
        case BF_INS_SUB_V:
            fprintf(fp, "memory[pointer] -= %d;\n", instr->argument);
            break;
        case BF_INS_INC_P:
            fprintf(fp, "pointer++;\n");
            break;
        case BF_INS_DEC_P:
            fprintf(fp, "pointer--;\n");
            break;
        case BF_INS_ADD_P:
            fprintf(fp, "pointer += %d;\n", instr->argument);
            break;
        case BF_INS_SUB_P:
            fprintf(fp, "pointer -= %d;\n", instr->argument);
            break;
        case BF_INS_BRANCH_Z:
            fprintf(fp, "while (memory[pointer] != 0) {\n");
            break;
        case BF_INS_BRANCH_NZ:
            fprintf(fp, "}\n");
            break;
        case BF_INS_JMP:
            // TODO: Implement if JMP is ever used.
            break;
        case BF_INS_HALT:
            break;
        case BF_INS_CLEAR:
            fprintf(fp, "memory[pointer] = 0;\n");
            break;
        case BF_INS_COPY:
            fprintf(fp, "if (memory[pointer] != 0) {\n");
            fprintf(fp, "pointer_holder = pointer + %d;\n", instr->argument);
            fprintf(fp, "memory[pointer_holder] = memory[pointer_holder] + memory[pointer];\n");
            fprintf(fp, "}\n");
            break;
        case BF_INS_MUL:
            fprintf(fp, "if (memory[pointer] != 0) {\n");
            fprintf(fp, "pointer_holder = pointer + %d;\n", instr->offset);
            fprintf(fp, "memory[pointer_holder] = memory[pointer_holder] + (%d * memory[pointer]);\n", instr->argument);
            fprintf(fp, "}\n");
            break;
        default:
            break;
        }
    }

    fprintf(fp, "\nfree(memory);\n");
    fprintf(fp, "return 0;\n\n");
    fprintf(fp, "error1:\n");
    fprintf(fp, "return 1;\n");
    fprintf(fp, "}\n");
}
